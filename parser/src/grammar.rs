//! Grammar for syntactic analysis
//! and additional semantic analysis.

#![expect(
    clippy::let_unit_value,
    reason = r"
    Grammar does not yet use extra context data,
    so code generated by Pomelo involves a let statement
    with the unit-typed placeholder extra data"
)]

use crate::symbols::*;
use aili_model::state::EdgeLabel;
use aili_translate::{
    property::PropertyKey,
    stylesheet::{expression::*, selector::*, *},
};
use derive_more::{Display, Error, From};
use pomelo::pomelo;

/// Error type returned by a parser when it irrecoverably fails.
///
/// Recoverable errors are recovered and the parser returns
/// a [`Stylesheet`] that is the valid portion of the input.
#[derive(Clone, PartialEq, Eq, Debug, Display, Error, From, Default)]
pub enum ParseError {
    /// Parser failed without providing any additional information.
    #[default]
    #[display("unknown parser failure")]
    Generic,

    /// Parser's stack has overflown.
    #[display("parser stack overflow")]
    StackOverflow,

    /// Failure due to an irrecoverable syntax error.
    #[display("irrecoverable syntax error: {_0}")]
    SyntaxError(SyntaxError),
}

/// Error type emited by a parser when incorrect syntax
/// is encountered.
///
/// Errors of this kind are generally recoverable.
#[derive(Clone, PartialEq, Eq, Debug, Display, Error)]
pub enum SyntaxError {
    /// Parser expected additional tokens at the end of input.
    #[display("unexpected end of input")]
    UnexpectedEnd,

    /// Parser encountered an unexpected token.
    #[display("unexpected token")]
    UnexpectedToken,

    /// An unrecognized edge name was used in a selector.
    #[display("unknown edge label name {:?}", _0.0)]
    InvalidEdgeLabel(InvalidSymbol),

    /// An unrecognized token was used as a function name.
    #[display("unknown function name {:?}", _0.0)]
    InvalidFunction(InvalidSymbol),

    /// An invalid literal was used in an expression.
    #[display("token {:?} which is not a literal cannot appear in an expression", _0.0)]
    InvalidUnquoted(InvalidSymbol),
}

pomelo! {
    %include {
        use super::*;
        use Expression::BinaryOperator as Bop;
        use Expression::UnaryOperator as Uop;
        use UnaryOperator::*;
        use BinaryOperator::*;
        use UnaryOperator::Plus as UnaryPlus;
        use UnaryOperator::Minus as UnaryMinus;
        use BinaryOperator::Plus as BinaryPlus;
        use BinaryOperator::Minus as BinaryMinus;
    }

    // Syntactic analysis errors
    %error ParseError;
    %stack_overflow { ParseError::StackOverflow }
    %syntax_error {
        if token.is_some_and(|t| t != Token::End) {
            Err(SyntaxError::UnexpectedToken.into())
        } else {
            Err(SyntaxError::UnexpectedEnd.into())
        }
    }

    %token
    /// Type of tokens accepted by the syntactic parser.
    #[derive(Clone, PartialEq, Eq, Debug)]
    pub enum Token<'a> {};

    // Underlying types of nonterminal symbols
    %type stylesheet Stylesheet;
    %type sheet_part Stylesheet;
    %type rule       StyleRule;
    %type body       Vec<StyleRuleItem>;
    %type proplist   Vec<StyleRuleItem>;
    %type proplist1  Vec<StyleRuleItem>;
    %type clause     StyleRuleItem;
    %type lvalue     StyleKey;
    %type rvalue     Expression;
    %type selector   Selector;
    %type selector1  Selector;
    %type selector2  Selector;
    %type condition  Expression;
    %type path       SelectorPath;
    %type rsegment   RestrictedSelectorSegment;
    %type segment    SelectorSegment;
    %type pathlist   Vec<SelectorPath>;
    %type limsel     LimitedSelector;
    %type limsel1    LimitedSelector;
    %type limpath    Vec<EdgeLabel>;
    %type limseg     EdgeLabel;
    %type matcher    EdgeMatcher;
    %type exact      EdgeLabel;
    %type extra      String;
    %type expr       Expression;
    %type rexpr      Expression;
    %type bop        BinaryOperator;
    %type uop        UnaryOperator;

    // Underlying types of terminal symbols
    %type Unquoted   &'a str;
    %type Quoted     &'a str;
    %type Int        u64;

    %type
    /// Special terminal symbol to signalize end of input.
    ///
    /// This symbol may be optionally pushed before ending the parser.
    /// This is necessary to get correct error reporting and partial results
    /// in case of failure at the end of input, which Pomelo does not do
    /// on its own.
    ///
    /// Calling [`Parser::end_of_input`] without pushing this token
    /// may lead to incorrect error reporting and loss of partial results
    /// in case of a failure at this point.
    End;

    // Operator precedence
    %right Question;
    %left Or;
    %left And;
    %left Eq Ne;
    %left Lt Le Gt Ge;
    %left Plus Minus;
    %left Asterisk Slash Percent;
    %nonassoc Not;

    // ======================================
    //                GRAMMAR
    // ======================================

    // The starting nonterminal symbol
    // Accept the End symbol optionally
    stylesheet ::= sheet_part(s) End?                  { s }

    // Rules in the stylesheet
    sheet_part ::=                                     { Stylesheet::default() }
    sheet_part ::= sheet_part(mut s) rule(r)           { s.0.push(r); s }
    rule ::= selector(s) body(b)                       { StyleRule { selector: s, properties: b } }

    // Rule body (the part that is not a selector)
    body ::= OpenBrace proplist CloseBrace;
    proplist ::= proplist1;
    proplist ::= proplist1(mut l) clause(c)            { l.push(c); l }
    proplist1 ::=                                      { Vec::new() }
    proplist1 ::= proplist1(mut l) clause(c) Semicolon { l.push(c); l }
    clause ::= lvalue(l) Colon rvalue(r)               { StyleRuleItem { key: l, value: r.into() } }
    lvalue ::= Quoted(s)                               { StyleKey::Property(PropertyKey::Attribute(s.to_owned())) }
    lvalue ::= Unquoted(s)                             { unquoted_style_key(s) }
    rvalue ::= rexpr;
    rvalue ::= Unquoted(s)                             { literal_expression_by_name(s).unwrap_or_else(|InvalidSymbol(s)| Expression::String(s)) }

    // Selectors
    selector ::= selector1;
    selector ::= selector1(s) extra(e)                 { s.with_extra(e) }
    selector1 ::= selector2;
    selector1 ::= selector2(s) EdgeMatcher             { s.selecting_edge() }
    selector2 ::= RootMatcher path(p)                  { Selector::from_path(p) }
    selector2 ::= path(p)                              { selector_from_not_root(p.0) }
    condition ::= If OpenParen expr CloseParen;
    path ::=                                           { [].into() }
    path ::= path(mut p) rsegment(s)                   { p.0.push(s); p }
    rsegment ::= segment(s)                            { s.into() }
    rsegment ::= segment(s) condition(c)               { RestrictedSelectorSegment { segment: s, condition: Some(c) } }
    segment ::= matcher(m)                             { SelectorSegment::Match(m) }
    segment ::= Many OpenParen path(p) CloseParen      { SelectorSegment::AnyNumberOfTimes(p) }
    segment ::= Alt OpenParen pathlist(l) CloseParen   { SelectorSegment::Branch(l) }
    pathlist ::= path(p)                               { vec![p] }
    pathlist ::= pathlist(mut l) Comma path(p)         { l.push(p); l }

    // Limited selectors
    limsel ::= limsel1;
    limsel ::= limsel1(s) extra(e)                     { s.with_extra(e) }
    limsel1 ::= limpath(p)                             { LimitedSelector::from_path(p) }
    limpath ::=                                        { Vec::new() }
    limpath ::= limpath(mut p) limseg(s)               { p.push(s); p }
    limseg ::= exact;
    limseg ::= Quoted(s)                               { EdgeLabel::Named(s.to_owned(), 0) }

    // Matchers in selectors (both full and limited)
    matcher ::= Asterisk                               { EdgeMatcher::Any }
    matcher ::= OpenBracket CloseBracket               { EdgeMatcher::AnyIndex }
    matcher ::= Quoted(s)                              { EdgeMatcher::Named(s.to_owned()) }
    matcher ::= Percent                                { EdgeMatcher::AnyNamed }
    matcher ::= exact(e)                               { EdgeMatcher::Exact(e) }
    exact ::= OpenBracket Int(i) CloseBracket          { EdgeLabel::Index(i as usize) }
    exact ::= Quoted(s) Hash Int(i)                    { EdgeLabel::Named(s.to_owned(), i as usize) }
    exact ::= Unquoted(s)                              { edge_label_from_name(s).map_err(SyntaxError::InvalidEdgeLabel)? }
    extra ::= Extra                                    { String::new() }
    extra ::= Extra OpenParen Unquoted(s) CloseParen   { s.to_owned() }

    // Expressions
    expr ::= rexpr;
    expr ::= Unquoted(s)                               { literal_expression_by_name(s).map_err(SyntaxError::InvalidUnquoted)? }
    rexpr ::= OpenParen expr CloseParen;
    rexpr ::= Quoted(s)                                { Expression::String(s.to_owned()) }
    rexpr ::= Int(i)                                   { Expression::Int(i) }
    rexpr ::= Unquoted(s) OpenParen expr(e) CloseParen { Uop(unary_function_by_name(s).map_err(SyntaxError::InvalidFunction)?, e.into()) }
    rexpr ::= Plus expr(e) [Not]                       { Uop(UnaryPlus, e.into()) }
    rexpr ::= Minus expr(e) [Not]                      { Uop(UnaryMinus, e.into()) }
    rexpr ::= Not expr(e)                              { Uop(Not, e.into()) }
    rexpr ::= expr(l) Plus expr(r)                     { Bop(l.into(), BinaryPlus, r.into()) }
    rexpr ::= expr(l) Minus expr(r)                    { Bop(l.into(), BinaryMinus, r.into()) }
    rexpr ::= expr(l) Asterisk expr(r)                 { Bop(l.into(), Mul, r.into()) }
    rexpr ::= expr(l) Slash expr(r)                    { Bop(l.into(), Div, r.into()) }
    rexpr ::= expr(l) Percent expr(r)                  { Bop(l.into(), Mod, r.into()) }
    rexpr ::= expr(l) Eq expr(r)                       { Bop(l.into(), Eq, r.into()) }
    rexpr ::= expr(l) Ne expr(r)                       { Bop(l.into(), Ne, r.into()) }
    rexpr ::= expr(l) Lt expr(r)                       { Bop(l.into(), Lt, r.into()) }
    rexpr ::= expr(l) Le expr(r)                       { Bop(l.into(), Le, r.into()) }
    rexpr ::= expr(l) Gt expr(r)                       { Bop(l.into(), Gt, r.into()) }
    rexpr ::= expr(l) Ge expr(r)                       { Bop(l.into(), Ge, r.into()) }
    rexpr ::= expr(l) And expr(r)                      { Bop(l.into(), And, r.into()) }
    rexpr ::= expr(l) Or expr(r)                       { Bop(l.into(), Or, r.into()) }
    rexpr ::= expr(c) Question expr(t) Colon expr(f)   { Expression::Conditional(c.into(), t.into(), f.into()) }
    rexpr ::= At                                       { Expression::Select(LimitedSelector::new().into()) }
    rexpr ::= At OpenParen limsel(s) CloseParen        { Expression::Select(s.into()) }
}

/// Shorthand for constructing a selector from a path that does not
/// start at the root node.
///
/// This is done by prepending a [`SelectorSegment::anything_any_number_of_times`]
/// to the path.
fn selector_from_not_root(
    segments: impl IntoIterator<Item = RestrictedSelectorSegment>,
) -> Selector {
    let starting_segment = SelectorSegment::anything_any_number_of_times().into();
    let segments = std::iter::once(starting_segment).chain(segments).collect();
    Selector::from_path(SelectorPath(segments))
}

// Re-export types generated by Pomelo
pub use parser::{Parser, Token};

#[cfg(test)]
mod test {
    use super::{Parser, SyntaxError, Token::*};

    #[test]
    fn empty_stylesheet() {
        Parser::new()
            .end_of_input()
            .expect("Empty input should be valid");
    }

    #[test]
    fn smallest_empty_rule() {
        let mut parser = Parser::new();
        let tokens = [RootMatcher, OpenBrace, CloseBrace];
        for token in tokens {
            parser
                .parse(token)
                .expect("Token should have been accepted");
        }
        parser
            .end_of_input()
            .expect("Parser should have been in valid terminating state");
    }

    #[test]
    fn end_before_rule_body() {
        let mut parser = Parser::new();
        parser
            .parse(RootMatcher)
            .expect("Root matcher should be valid here");
        let err = parser.parse(End).expect_err("Parser should have failed");
        assert_eq!(err, SyntaxError::UnexpectedEnd.into());
    }

    #[test]
    fn end_inside_rule_body() {
        let mut parser = Parser::new();
        let tokens = [RootMatcher, OpenBrace];
        for token in tokens {
            parser
                .parse(token)
                .expect("Token should have been accepted");
        }
        let err = parser.parse(End).expect_err("Parser should have failed");
        assert_eq!(err, SyntaxError::UnexpectedEnd.into());
    }
}
